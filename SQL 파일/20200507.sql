-- 다중열 서브쿼리 사용하기
-- 'Karen'고 같은 직종에 종사하고, 같은 부서에 소속되어 있는 사원의 아이디, 이름, 직종, 부서아이디 조회하기
SELECT JOB_ID, DEPARTMENT_ID
FROM EMPLOYEES
WHERE FIRST_NAME = 'Karen';

SELECT *
FROM EMPLOYEES
WHERE (JOB_ID, DEPARTMENT_ID) IN (SELECT JOB_ID, DEPARTMENT_ID
                                  FROM EMPLOYEES
                                  WHERE FIRST_NAME = 'Karen');

-- 부서별 최고 급여를 받는 사원의 아이디, 이름, 급여, 부서아이디를 조회하기
SELECT DEPARTMENT_ID, MAX(SALARY)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID;

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE (DEPARTMENT_ID, SALARY) IN (SELECT DEPARTMENT_ID, MAX(SALARY)
                                  FROM EMPLOYEES
                                  WHERE DEPARTMENT_ID IS NOT NULL
                                  GROUP BY DEPARTMENT_ID)
ORDER BY EMPLOYEE_ID;

-- 스칼라 서브쿼리 사용하기
-- 전체 평균보다 적은 급여를 받는 사원의 아이디, 이름, 급여, 평균급여, 평균급여와의 차이를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY,
       TRUNC((SELECT AVG(SALARY) FROM EMPLOYEES) - SALARY) AS SALARY_GAP
FROM EMPLOYEES
WHERE SALARY < (SELECT AVG(SALARY)
                FROM EMPLOYEES)
ORDER BY SALARY_GAP;

-- 부서아이디, 부서명, 해당 부서의 사원수를 조회하기
SELECT OUTTER.DEPARTMENT_ID, OUTTER.DEPARTMENT_NAME,
       (SELECT COUNT(*)
        FROM EMPLOYEES INNER
        WHERE INNER.DEPARTMENT_ID = OUTTER.DEPARTMENT_ID) CNT
FROM DEPARTMENTS OUTTER;

-- 20000달러 이상은 전체 평균급여의 10%를 보너스로, 10000달러 이상은 15%, 그 외는 20% 보너스로 지급하려고 한다.
-- 아이디, 이름, 급여, 보너스 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY,
CASE
    WHEN SALARY >= 20000 THEN TRUNC((SELECT AVG(SALARY) FROM EMPLOYEES) * 0.1)
    WHEN SALARY >= 10000 THEN TRUNC((SELECT AVG(SALARY) FROM EMPLOYEES) * 0.15)
    ELSE TRUNC((SELECT AVG(SALARY) FROM EMPLOYEES) * 0.2)
    END BONUS
    FROM EMPLOYEES;
    
    -- 전체 평균급여보다 급여를 많이 받는 사원의 이름, 급여를 조회하기
    SELECT FIRST_NAME, SALARY
    FROM EMPLOYEES
    WHERE SALARY > (SELECT AVG(SALARY)
                    FROM EMPLOYEES);
                    
-- 자신이 소속된 소속부서의 평균급여보다 많은 급여를 받는 사원의 이름, 급여를 조회하기
SELECT OUTTER.FIRST_NAME, OUTTER.SALARY
FROM EMPLOYEES OUTTER
WHERE OUTTER.SALARY > (SELECT AVG(INNER.SALARY)
                       FROM EMPLOYEES INNER
                       WHERE INNER.DEPARTMENT_ID = OUTTER.DEPARTMENT_ID);
-- 외부 SQL문이 실행되어서 행을 가져온다.(후보행)
-- 후보행의 행마다 DEPARTMENT_ID값을 가져와서 서브쿼리를 실행한다.
-- 서브쿼리의 결과값을 사용해서 후보행을 검증한다.
-- 후보행이 남지 않을 때까지 반복한다.

SELECT TO_DATE('20200101', 'YYYYMMDD') + LEVEL - 1
FROM DUAL
CONNECT BY LEVEL <= 31;

-- EXISTS 연산자 사용하기
-- 부하직원을 가지고 있는 직원을 조회하기
SELECT *
FROM EMPLOYEES 상사
WHERE (SELECT COUNT(*)
       FROM EMPLOYEES 부하
       WHERE 부하.MANAGER_ID = 상사.EMPLOYEE_ID) > 0; -- COUNT() 사용 비추천
       
SELECT *
FROM EMPLOYEES 상사
WHERE EXISTS (SELECT 1
              FROM EMPLOYEES 부하
              WHERE 부하.MANAGER_ID = 상사.EMPLOYEE_ID); -- EXISTS 사용 추천
              
-- WITH 절
WITH DEPT_COSTS AS  -- 부서이름, 부서총급여
(SELECT B.DEPARTMENT_NAME, SUM(A.SALARY) AS DEPT_TOTAL
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
GROUP BY B.DEPARTMENT_NAME),
AVG_COST AS  -- 부서별 총 급여에 대한 평균급여
(SELECT SUM(DEPT_TOTAL)/COUNT(*) AS DEPT_AVG
FROM DEPT_COST)
SELECT *
FROM DEPT_COSTS
WHERE DEPT_TOTAL > (SELECT DEPT_AVG    -- 부서총급여가 평균급여
                    FROM AVG_COST)
ORDER BY DEPARTMENT_NAME;

-- 118번 사원의 상사를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 118
CONNECT BY PRIOR MANAGER_ID = EMPLOYEE_ID;

-- 101번 직원의 모든 부하 조회하기
SELECT LPAD(EMPLOYEE_ID, LEVEL * 4, ' '), FIRST_NAME, MANAGER_ID
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 101
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;

-- 100(사장)의 모든 부하직원 조회
SELECT LPAD(FIRST_NAME, LENGTH(FIRST_NAME) + LEVEL * 4 - 4, ' ')
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 100
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;

-- 100의 모든 부하직원 조회, Neena는 제외(Neena의 부하도 제외)
SELECT LPAD(FIRST_NAME, LENGTH(FIRST_NAME) + LEVEL * 5 - 5, ' ')
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 100
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID AND FIRST_NAME != 'Neena';

-- 100의 부하직원 조회하기
SELECT LPAD(FIRST_NAME, LENGTH(FIRST_NAME) + LEVEL * 5 - 5, ' ')
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 100
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID AND LEVEL <= 2;

-- 2020/01/01 ~ 2020/12/31 날짜 만들기
SELECT TO_DATE('2020/01/01', 'YYYY/MM/DD') + LEVEL - 1
FROM DUAL
CONNECT BY LEVEL <= 366;

-- 2005년도 월별 입사자수 조회하기
SELECT TO_CHAR(HIRE_DATE, 'YYYY-MM'), COUNT(*)
FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE, 'YYYY') = '2003'
GROUP BY TO_CHAR(HIRE_DATE, 'YYYY-MM')
ORDER BY 1;

WITH MONTHS AS
(SELECT '2003-' ||
    CASE
        WHEN LEVEL < 10 THEN '0' || LEVEL
        ELSE TO_CHAR(LEVEL)
    END MON
FROM DUAL
CONNECT BY LEVEL <= 12),
MONTH_EMP_COUNT AS
(SELECT TO_CHAR(HIRE_DATE, 'YYYY-MM') MON, COUNT(*) CNT
FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE, 'YYYY') = '2003'
GROUP BY TO_CHAR(HIRE_DATE, 'YYYY-MM'))
SELECT A.MON, NVL(B.CNT, 0) CNT
FROM MONTHS A, MONTH_EMP_COUNT B
WHERE A.MON = B.MON(+)
ORDER BY A.MON ASC;